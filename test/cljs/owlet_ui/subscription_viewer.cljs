(ns owlet-ui.subscription-viewer
  "Provides facilities to create an ad hoc Reagent component just for examining
  the values generated by re-frame subscriptions. This is useful for testing
  and development of an app's re-frame data flow. For notes about data flow,
  see https://github.com/Day8/re-frame#the-2nd-flow"
  [:require [cljs.reader :refer [read-string]]
            [reagent.core :refer [render]]
            [re-frame.core :as rf]])


(defn component-with-subscriptions
  "Creates a \"Form-2\" re-frame component, a function that subscribes to the
  given subscription vectors and returns a function that generates Hiccup code
  using the subscriptions' reactive values. The Hiccup code describes a very
  simple component listing the given subscription vectors and their current
  reactive values. The values are rendered as text by passing them to pr-str.

  The given DOM elememt id is required to assign unique element ids to the
  DOM span elements containing the subscription vectors and their rendered
  reactive values. Then you can call this function with different arguments to
  make a page showing the multiple differing components at different locations.
  "
  [dom-id & subscribe-vecs]
  (fn []
    (let [sub-reactions (map rf/subscribe subscribe-vecs)
          sub-count     (count sub-reactions)
          indexed-subs  (map vector (range) subscribe-vecs sub-reactions)
          id->span-id   (fn [& suffix] (keyword
                                         (apply str "span#" dom-id suffix)))]
      (fn [] (apply vector
                    :pre

                    [:div "Results from "
                     [(id->span-id "_COUNT") sub-count]
                     " subscription"
                     (if (= 1 sub-count) "" "s")
                     ":\n\n"]

                    (for [[id sub-vec sub-reaction] indexed-subs]
                      [:div [(id->span-id "_KEY" id) (str sub-vec)]
                       " --> "
                       [(id->span-id "_VAL" id)
                        (pr-str @sub-reaction)]]))))))


(defn result-at-id
  "Converts the given arguments to strings, concatenates them, finds the DOM
  element in the current document at that element id, reads it as EDN data,
  and returns the resulting Clojure value. If no such element can be found,
  nil is returned."
  [& id-parts]
  (some-> js/document
          (.getElementById (apply str id-parts))
          .-innerHTML
          read-string))


(defn results
  ([dom-id]  (into (array-map) (for [n (range (result-at-id dom-id "_COUNT"))]
                                 [(result-at-id dom-id "_KEY" n)
                                  (result-at-id dom-id "_VAL" n)])))

  ([dom-id n] (result-at-id dom-id "_VAL" n)))


(defn render-subs-at
  [dom-id & subscribe-vecs]
  (partial render
           [(apply component-with-subscriptions dom-id subscribe-vecs)]
           (.getElementById js/document dom-id)))
